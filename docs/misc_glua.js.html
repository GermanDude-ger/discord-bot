<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: misc/glua.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: misc/glua.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Command = require("discord.js-commando").Command
const RichEmbed = require("discord.js").RichEmbed

module.exports = class GLuaCommand extends Command {
	constructor(client) {
		super(client, {
			name: 'glua',
			group: 'util',
			memberName: 'glua',
			description: 'Search the GMod Lua Docs.',
			args: [{
				key: 'term',
				label: 'Search Term',
				prompt: 'Search Term',
				type: 'string',
			},{
				key: 'pos',
				label: 'Selector',
				prompt: 'Selector',
				type: 'integer',
				default: 0
			}]
		})
	}

	/**
	 * @param {CommandMessage} msg The incoming message.
	 * @param {Object|string|Array&lt;string>} args The command arguments.
	 * @param {boolean} _ If the incoming message is from a pattern match.
	 * @returns {Promise&lt;Message>}
	 */
	async run(msg, args, _){
		if (!this.dataTable){return msg.reply("this command hasn't loaded yet.")}

		let matches = filter_matches(this.dataTable, args.term.toLowerCase())
		if (matches.length === 0){return msg.reply("there are no matching articles.")}
		if (matches.length === 1){args.pos = 1}

		if (args.pos === 0){
			let reply = build_upto(matches, function(table, index){return `${index + 1}: ${table[index].title}`}, 1500)
			if (reply){
				return msg.reply(`\n${reply}`)
			} else {
				return msg.reply(`there are ${matches.length} matching articles. Please narrow your search.`)
			}
		} else if (args.pos > matches.length) {
			return msg.reply(`${args.pos} is out of range for your search, the maximum is ${matches.length}`)
		} else {
			return msg.channel.send("", build_rich(matches[args.pos - 1]))
		}
	}
}

function filter_matches(table, title){return table.filter((v) => {return v.title.toLowerCase().indexOf(title) > -1})}
function build_upto(table, rowFunc, upto){
	let out = ""
	let index = 0

	do {
		out += rowFunc(table, index) + "\n"
		index++
	} while (out.length &lt; upto &amp;&amp; index &lt; table.length)

	if (index >= table.length){
		return out
	} else {
		return false
	}
}

const html_ents = {
	"&amp;quot;": "\"",
	"&amp;apos;": "'"
}

function proc_html_ents(html){
	for (let ent in html_ents){html = html.replace(new RegExp(ent, 'g'), html_ents[ent])}
	return html
}

const state_cols = {
	server: [52, 152, 219],
	shared: [191, 34, 230],
	client: [211, 84, 0],
	menu: [39, 174, 96]
}
function build_rich(row){
	const regex_header = /&lt;div class="function_line">([\s\S]*?)&lt;\/div>/g
	const regex_deprec = /&lt;div class="deprecatedfunc">/g

	const regex_arg = /&lt;div class="argument">([\s\S]*?)&lt;\/div>[\s]&lt;\/div>/g
	const regex_arg_type = /&lt;a(.*?)>(.*?)&lt;\/a>/g
	const regex_arg_name = /a> (.*?)(=(.*?))?&lt;\/span>/g
	const regex_arg_desc = /&lt;div style="margin-left: 32px;">(.*)/g

	const regex_func = /a> (.*?)[,&lt;]/g
	const regex_class = /&lt;a(.*?)>(.*?)&lt;\/a>/g
	const regex_desc = /id="Description">[\s\S]*?1>\s&lt;p>([\s\S]*?)&lt;\/p>|class="deprecatedfunc">[\s\S]*?&lt;br>[\s\S]*?&lt;br>&lt;br>([\s\S]*?)&lt;h1/g

	let html = row.html

	let res = regex_header.exec(html)
	let header = res[1]
	let deprecated = regex_deprec.exec(html) ? "This function is deprecated and may be removed in a future version." : ""

	let func_name = header.slice(0, header.indexOf("(")) + "("
	let func_url = `https://samuelmaddock.github.io/glua-docs/#?q=${func_name.slice(0, -1).replace(":", ".")}`

	let func_name_test, func_arg_name, func_class
	let arg_num = 0

	while ((func_name_test = regex_func.exec(header)) !== null){
		func_class = regex_class.exec(header)[2]
		func_arg_name = func_name_test[1]
		func_name += `*${func_class}* ${func_arg_name}, `
		arg_num++
	}
	if (arg_num !== 0){func_name = func_name .slice(0, -2)}
	func_name += ")"

	let desc = ""
	let desc_out = regex_desc.exec(html)
	let desc_str = desc_out [1] !== undefined ? desc_out[1] : (desc_out[2] !== undefined ? desc_out [2].replace(/&lt;\/div> /g, "\n\n") : 'None Found')
	desc += "" + desc_str.replace(/&lt;br>/g, "\n").replace(/&lt;a(.*?)>(.*?)&lt;\/a>/g, "$2") + ""

	let args = ""
	let arg_count = 1

	let m = regex_arg.exec(html)
	while (m){
		if (m.index === regex_arg.lastIndex){regex_arg.lastIndex++}
		if (m === null){continue}

		let argType = regex_arg_type.exec(m[1])[2]
		regex_arg_type.lastIndex = 0

		let argName = regex_arg_name.exec(m[1])[1]
		regex_arg_name.lastIndex = 0

		let argDefault = regex_arg_name.exec(m[1])[3]
		regex_arg_name.lastIndex = 0

		let argDesc = regex_arg_desc.exec(m[1])[1].replace(/&lt;a(.*?)>(.*?)&lt;\/a>/g, "$2")
		regex_arg_desc.lastIndex = 0

		args += "```"
		args += "Argument " + (arg_count++) + ": " + argName + " (" + argType + ")"
		if (argDefault !== undefined){args += " (default: " + argDefault + ")"}
		args += "\n" + argDesc + "\n\n"
		args += "```"

		m = regex_arg.exec(html)
	}

	let rich = new RichEmbed()
	rich.setAuthor(func_name, "", row.url)
	rich.setDescription(proc_html_ents(desc))
	if (deprecated !== ""){
		rich.addField("WARNING", deprecated)
	}
	rich.addField("Lua State", row.scope.toUpperCase(), true)
	if (arg_count === 1){
		rich.addField("Arguments", "None")
	} else {
		rich.addField("Arguments", proc_html_ents(args))
	}
	rich.setFooter(func_url)
	rich.setColor(state_cols[row.scope])
	return rich
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Feb 21 2019 09:19:20 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
